/*
//*git clone 
命令在真实的环境下的作用是在本地创建一个远程仓库的拷贝

远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。
Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, 
（更新了远程分支之后）再用远程分享你的工作成果。

你可能想问这些远程分支的前面的 o/ 是什么意思呢？好吧, 远程分支有一个命名规范 —— 它们的格式是:

<remote name>/<branch name>
因此，如果你看到一个名为 o/main 的分支，那么这个分支就叫 main，远程仓库的名称就是 o。

大多数的开发人员会将它们主要的远程仓库命名为 origin，并不是 o。这是因为当你用 git clone 某个仓库时，Git 已经帮你把远程仓库的名称设置为 origin 了

不过 origin 对于我们的 UI 来说太长了，因此不得不使用简写 o :) 但是要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 origin!




Git 变成了分离 HEAD 状态，当添加新的提交时 o/main 也不会更新。
这是因为 o/main 只有在远程仓库中相应的分支更新了以后才会更新。

//*get fetch(获取数据)

C2,C3 被下载到了本地仓库，
同时远程分支 o/main 也被更新，反映到了这一变化


从远程仓库下载本地仓库中缺失的提交记录
更新远程分支指针(如 o/main)
git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态

你可以将 git fetch 的理解为单纯的下载操作。


//*git pull

先抓取更新再合并到本地分支这个流程很常用，
因此 Git 提供了一个专门的命令来完成这两个操作。
它就是我们要讲的 git pull。

我们用 fetch 下载了 C3, 然后通过 git merge o/main 合并了这一提交记录。
现在我们的 main 分支包含了远程仓库中的更新（在本例中远程仓库名为 origin）

这清楚地说明了 git pull 就是 git fetch 和 git merge 的缩写！


//*git push
git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。
一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！

在教程中我们使用的是 upstream。
这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。



*/